#!/usr/bin/env python3
"""Utility for round-tripping MyST content through the XML pipeline.

Example usage:

    uv run python scripts/myst_roundtrip.py --file docs/sample.md
    uv run python scripts/myst_roundtrip.py --text "- item\n  detail\n"

Escape sequences inside ``--text`` are interpreted by default (pass
``--literal-text`` to disable), making it easy to paste snippets with ``\n``
line breaks directly from the clipboard.

The script prints the generated XML and the reconstructed document so you can
quickly inspect how the parser behaves on arbitrary snippets.
"""

from __future__ import annotations

import argparse
from pathlib import Path
import sys

REPO_ROOT = Path(__file__).resolve().parents[1]
SRC_PATH = REPO_ROOT / "src"
if SRC_PATH.exists() and str(SRC_PATH) not in sys.path:
    sys.path.insert(0, str(SRC_PATH))

from trans_lib.xml_manipulator_mod.mod import myst_to_xml
from trans_lib.xml_manipulator_mod.xml import reconstruct_from_xml


def _read_input(
    file: Path | None,
    text: str | None,
    use_stdin: bool,
    unescape_text: bool,
) -> str:
    """Load the source string from the selected input mode."""
    if file is not None:
        return file.read_text(encoding="utf-8")
    if text is not None:
        return (
            bytes(text, "utf-8").decode("unicode_escape")
            if unescape_text
            else text
        )
    if use_stdin:
        return sys.stdin.read()
    raise ValueError("One of --file, --text, or --stdin must be provided")


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Round-trip MyST markdown: parse to XML and reconstruct back.",
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "--file",
        type=Path,
        help="Path to a file containing MyST content to round-trip.",
    )
    group.add_argument(
        "--text",
        help="Literal MyST content passed on the command line.",
    )
    group.add_argument(
        "--stdin",
        action="store_true",
        help="Read MyST content from standard input.",
    )
    parser.add_argument(
        "--show-placeholders",
        action="store_true",
        help="Print the placeholder mapping generated by myst_to_xml.",
    )
    parser.add_argument(
        "--literal-text",
        action="store_true",
        help="Treat --text input literally (do not interpret escape sequences like \\n).",
    )
    return parser


def main(argv: list[str] | None = None) -> int:
    parser = _build_parser()
    args = parser.parse_args(argv)

    source = _read_input(
        args.file,
        args.text,
        args.stdin,
        unescape_text=not args.literal_text,
    )
    xml_output, placeholders, _ = myst_to_xml(source)
    reconstructed = reconstruct_from_xml(xml_output)

    print("=== XML ===")
    print(xml_output)
    print("=== RECONSTRUCTED ===")
    print(reconstructed)

    if args.show_placeholders:
        print("=== PLACEHOLDERS ===")
        for ph_id, content in placeholders.items():
            print(f"{ph_id}: {content!r}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
